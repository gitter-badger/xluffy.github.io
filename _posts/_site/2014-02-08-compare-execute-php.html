<h3 id="s_lc">Sơ lược:</h3>

<p>Về cơ bản với Web server là Apache ta có thể có 3 cách biên dịch và thực thi các mã .php như sau:</p>

<ul>
<li>Biên dịch PHP như một static module của Apache.</li>

<li>Biên dịch PHP như một dynamic module của Apache.</li>

<li>Biên dịch PHP như một CGI interprete (cụ thể ở đây là FastCGI)</li>
</ul>

<h3 id="bin_dch_php_nh_mt_static_module_ca_apache">Biên dịch PHP như một static module của Apache.</h3>

<p>Với cách này thì PHP module sẽ được biên dịch chung với Apache và không thể remove cũng như cài đặt lại PHP nếu không biên dịch lại Apache.</p>

<p>Lợi điềm của cách này là tốc độ nhanh (vì PHP sẽ được load ngay khi start Apache) tuy nhiên nhược điểm là nếu cần cập nhật PHP thì buộc phải complie lại cả Apache.</p>

<p>Option để biên dịch dạng static module với source PHP như sau</p>

<p><code>--with-apache[=DIR]
    Build a static Apache module. DIR is the top-level Apache build directory, defaults to /usr/local/apache.</code></p>

<h3 id="bin_dch_php_nh_mt_dynamic_module_ca_apache">Biên dịch PHP như một dynamic module của Apache.</h3>

<p>Về cơ bản thì static và dynamic là như nhau, chỉ khác nhau ở cách hoạt động. Nghĩa là khi bạn sẽ cần load thêm module php trong config của Apache. Và khi có một request nào gửi tới Web server thực thi một script PHP thì module mới <strong>thực sự</strong> được load lên (không giống như dạng static là load sẵn).</p>

<p>Option để biên dịch dạng dynamic module:</p>

<p><code>--with-apxs2[=FILE]
    Build shared Apache 2.0 module. FILE is the optional pathname to the Apache apxs tool; defaults to apxs</code></p>

<p>Lợi điểm của cách biên dịch này là ta có thể dễ dàng biên dịch, cập nhật lại PHP mà không ảnh hưởng tới Apache</p>

<p><strong>Nhược điểm của cả 2 cách trên</strong> là PHP module hoạt động như một phần của Apache, nghĩa là các process sinh ra khi thực thi một script PHP nào đó sẽ có UserID là user chạy Apache luôn, điều này làm ảnh hưởng đến tính bảo mật của hệ thống.</p>

<p><strong>Ưu điểm của cả 2 cách trên</strong> là PHP module được sinh ra sẽ như một <strong>theard</strong> của một process cha Apache, nên sẽ lightweight và tiết kiệm RAM hơn.</p>

<p><strong>Tổng kết:</strong> Dù biên dịch static hay dynamic thì cơ chế xử lý của PHP trong mod_php là như nhau. Nghĩa là khi có request tới thì</p>

<p>sẽ vẫn đá qua module PHP để xử lý (tương tự như cách xử lý ở các module khác). Điều khác biệt chỉ ở lần thực thi script PHP đầu tiên (static thì</p>

<p>load sẵn, dynamic thì khi có request đầu tiên mới load) tuy nhiên ở những lần thực thi sau thì cả 2 đều như nhau, không cần phải load lại module PHP nữa.</p>

<h3 id="bin_dch_php_nh_mt_cgi_interprete_c_th__y_l_fastcgi">Biên dịch PHP như một CGI interprete (cụ thể ở đây là FastCGI)</h3>

<p>Lưu ý là FastCGI là một chuẩn giao thức liên lạc (communication protocol).</p>

<p>FastCGI là một dạng <em>server</em> tách rời với Apache (thực chất là trên cùng một server). Khi có một request đi vào, Apache sẽ connect và chuyển request đó cho FastCGI server (Apache lúc này là FastCGI client). FastCGI và Apache giao tiếp với nhau qua kết nối TCP hoặc Unix socket.</p>

<p>Điểm lợi của phương pháp này là Apache (FastCGI client) và Application Server (FastCGI server) sẽ chạy thông qua những user độc lập. Nghĩa là khi có request thực thi một script PHP, Apache sẽ đẩy qua cho FastCGI server xử lý, FastCGI sẽ sinh ra một process xử lý và trả về kết quả cho Apache, xong xuôi thì process đó cũng được stop.</p>

<p>Tóm lại là với cách này, ta sẽ có những process của Apache và những external process. Chính điều này làm cho FastCGI sẽ không thể lightweight như cách biên dịch PHP module được.</p>

<p>Đối với Web server là Apache ta có thể sử dụng mod_fastcgi hoặc mod_fcgi</p>

<p>Kết nối ở dạng Unix Socket</p>

<p><code>FastCgiExternalServer /var/www/php5.external -socket /var/run/php5-fpm.sock</code></p>

<p>Kết nối ở dạng TCP</p>

<p><code>FastCgiExternalServer /var/www/php5.external -socket /var/run/php5-fpm.sock</code></p>